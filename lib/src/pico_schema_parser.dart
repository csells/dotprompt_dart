// -----------------------------------------------------------------------------
// Picoschema Parser with Nested Type Support
// -----------------------------------------------------------------------------
// Spec: https://google.github.io/dotprompt/reference/picoschema/
// Uses the petitparser package to parse the Picoschema DSL into an AST.
// The parser now handles nested object definitions based on indentation.
// -----------------------------------------------------------------------------
// USAGE
//   final parser = PicoschemaParser();
//   final result = parser.parse(schemaText);
//   if (result.isSuccess) {
//     final root = result.value as ObjectField;
//     print(root.pretty());
//   } else {
//     print(result.message);
//   }
// -----------------------------------------------------------------------------
// Author: Generated by ChatGPT ("Chappy")
// -----------------------------------------------------------------------------

// ignore_for_file: public_member_api_docs

import 'package:petitparser/petitparser.dart';

// -----------------------------------------------------------------------------
// Grammar Definition (per‑line)
// -----------------------------------------------------------------------------
// We parse one logical "line" at a time – indentation, a header, and optional
// description. The higher‑level PicoschemaParser class then walks the list of
// parsed lines and builds the nested AST according to indentation level.
// -----------------------------------------------------------------------------

class _LineGrammar extends GrammarDefinition {
  // Helpers -------------------------------------------------------------------
  Parser _token(Object source) =>
      source is Parser
          ? source.flatten().trim(_space())
          : string(source.toString()).flatten().trim(_space());

  Parser _space() => whitespace().star();
  Parser _newline() => char('\n');

  Parser _indent() => whitespace().star().flatten().map((s) => s.length);

  // Identifiers and literals --------------------------------------------------
  Parser _identifier() => _token(
    (letter() | char('_') | char('*')) &
        (word() | char('_') | char('-') | char('*')).star(),
  );

  Parser _scalarType() => _token(
    string('string') |
        string('number') |
        string('integer') |
        string('boolean') |
        string('null') |
        string('any'),
  );

  Parser _enumType() =>
      _token(char('[')) &
      _identifier()
          .plusSeparated(char(',').trim())
          .map((list) => list.elements.cast<String>()) &
      _token(char(']'));

  Parser _fieldType() => _scalarType() | _enumType() | _identifier();

  Parser _optionalMark() => char('?');
  Parser _colon() => _token(char(':'));

  Parser _inlineDescription() =>
      (char(',') & any().starLazy(_newline())).pick(1).optional();

  // Field header with inline type --------------------------------------------
  Parser _fieldHeader() =>
      _identifier().trim().map((n) => n as String) &
      _optionalMark().optional() &
      _colon() &
      _fieldType() &
      _inlineDescription();

  // Object header (no inline type) -------------------------------------------
  Parser _objectHeader() =>
      _identifier().trim().map((n) => n as String) &
      _optionalMark().optional() &
      _colon() &
      _inlineDescription();

  // Wildcard header -----------------------------------------------------------
  Parser _wildcardHeader() =>
      string('(*)').flatten() & _colon() & _fieldType() & _inlineDescription();

  // Compose a full line -------------------------------------------------------
  @override
  Parser start() => ref0(_line).end();

  Parser _line() =>
      _indent() &
      (ref0(_wildcardHeader) | ref0(_fieldHeader) | ref0(_objectHeader)) &
      _newline().optional();
}

// -----------------------------------------------------------------------------
// Intermediate Data Structure (indent + parsed node)
// -----------------------------------------------------------------------------

class _ParsedLine {
  // true when node expects nested children
  _ParsedLine(this.indent, this.node, {this.opensObject = false});
  final int indent;
  final SchemaNode node;
  final bool opensObject;
}

// -----------------------------------------------------------------------------
// High‑level Parser that assembles the full AST
// -----------------------------------------------------------------------------

class PicoschemaParser {
  PicoschemaParser() {
    _lineParser = _LineGrammar().build();
  }

  late final Parser _lineParser;

  ParseResult parse(String text) {
    final lines = text.split(RegExp(r'\r?\n')); // keep logical new‑lines
    final parsedLines = <_ParsedLine>[];

    for (final raw in lines) {
      final result = _lineParser.parse('$raw\n'); // _line expects trailing NL
      if (result is Failure) {
        return ParseResult.failure(
          result.message,
        ); // bubble the error – contains proper message & position
      }
      final values = result.value as List;
      final indent = values[0] as int;
      final payload = values[1] as List; // depends on which header matched

      // Dispatch according to which header matched --------------------------
      _ParsedLine mapToLine(List p) {
        // Wildcard ----------------------------------------------------------
        if (p[0] == '(*)') {
          final valueType = p[2];
          final desc = p.length > 3 ? p[3] as String? : null;
          return _ParsedLine(
            indent,
            WildcardField(valueType, description: desc),
          );
        }

        // Field header ------------------------------------------------------
        if (p.length >= 4 && p[2] == ':') {
          final name = p[0] as String;
          final optional = p[1] != null;
          final dynamic typePart = p[3];
          final desc = p[4] as String?;

          // Enum? -----------------------------------------------------------
          if (typePart is List<String>) {
            return _ParsedLine(
              indent,
              EnumField(name, typePart, optional: optional, description: desc),
            );
          }

          // Scalar / reference / array syntax ------------------------------
          final typeStr = typePart.toString();
          if (typeStr.startsWith('[') && typeStr.endsWith(']')) {
            // Inline array of enum already handled – so treat as Array
            final inner = typeStr.substring(1, typeStr.length - 1);
            return _ParsedLine(
              indent,
              ArrayField(name, inner, optional: optional, description: desc),
            );
          }

          return _ParsedLine(
            indent,
            ScalarField(name, typeStr, optional: optional, description: desc),
          );
        }

        // Object header -----------------------------------------------------
        if (p.length >= 3 && p[2] == ':') {
          final name = p[0] as String;
          final optional = p[1] != null;
          final desc = p[3] as String?;
          final obj = ObjectField(
            name,
            [],
            optional: optional,
            description: desc,
          );
          return _ParsedLine(indent, obj, opensObject: true);
        }

        throw StateError('Unrecognized line structure: $p');
      }

      parsedLines.add(mapToLine(payload));
    }

    // Build nested structure -------------------------------------------------
    final root = ObjectField('root', []);
    final stack = <({int indent, ObjectField obj})>[(indent: -1, obj: root)];

    for (final pl in parsedLines) {
      // Find the correct parent by indentation ------------------------------
      while (pl.indent <= stack.last.indent) {
        stack.removeLast();
      }
      final parentObj = stack.last.obj;
      parentObj.properties.add(pl.node);

      if (pl.opensObject && pl.node is ObjectField) {
        stack.add((indent: pl.indent, obj: pl.node as ObjectField));
      }
    }

    return ParseResult.success(root);
  }
}

// -----------------------------------------------------------------------------
// Custom Success to conform to PetitParser's Result interface
// -----------------------------------------------------------------------------

class ParseResult {
  ParseResult.success(this.value) : isSuccess = true, message = '';
  ParseResult.failure(this.message) : isSuccess = false, value = null;

  final bool isSuccess;
  final String message;
  final dynamic value;
}

// -----------------------------------------------------------------------------
// AST Node Definitions (same as before, plus helpers)
// -----------------------------------------------------------------------------

abstract class SchemaNode {
  String get name;
  String pretty([int indent = 0]);
}

class ScalarField extends SchemaNode {
  ScalarField(this.name, this.type, {this.optional = false, this.description});
  @override
  final String name;
  final bool optional;
  final String type;
  final String? description;

  @override
  String pretty([int indent = 0]) =>
      '${' ' * indent}$name${optional ? '?' : ''}: $type';
}

class ArrayField extends SchemaNode {
  ArrayField(
    this.name,
    this.elementType, {
    this.optional = false,
    this.description,
  });
  @override
  final String name;
  final bool optional;
  final String elementType;
  final String? description;

  @override
  String pretty([int indent = 0]) =>
      '${' ' * indent}$name${optional ? '?' : ''}: [$elementType]';
}

class EnumField extends SchemaNode {
  EnumField(this.name, this.values, {this.optional = false, this.description});
  @override
  final String name;
  final bool optional;
  final List<String> values;
  final String? description;

  @override
  String pretty([int indent = 0]) =>
      '${' ' * indent}$name${optional ? '?' : ''}: [${values.join(', ')}]';
}

class ObjectField extends SchemaNode {
  ObjectField(
    this.name,
    this.properties, {
    this.optional = false,
    this.description,
  });
  @override
  final String name;
  final bool optional;
  final List<SchemaNode> properties;
  final String? description;

  @override
  String pretty([int indent = 0]) {
    final buffer = StringBuffer('${' ' * indent}$name${optional ? '?' : ''}:');
    for (final p in properties) {
      buffer.writeln();
      buffer.write(p.pretty(indent + 2));
    }
    return buffer.toString();
  }
}

class WildcardField extends SchemaNode {
  WildcardField(this.valueType, {this.description});
  @override
  final String name = '*';
  final String valueType;
  final String? description;

  @override
  String pretty([int indent = 0]) => '${' ' * indent}(*): $valueType';
}
